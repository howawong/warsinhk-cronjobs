// const req = {
//   // The spreadsheet to request.
//   spreadsheetId: '1dgk1inO4DWA89jQGYqVmWgKvQXGW2dsMrOnbGMsAo9M',

//   // The ranges to retrieve from the spreadsheet.
//   range: 'master!A1:Q',
//   auth,
// };
const Promise = require('bluebird');
const request = Promise.promisifyAll(require('request'));

const { google } = require('googleapis');
const sheets = google.sheets('v4');
const ss = Promise.promisifyAll(sheets.spreadsheets.values);

const mkdirp = require('mkdirp');
const fs = require('fs');
const path = require('path');
const parse = require('csv-parse/lib/sync');
const moment = require('moment');

require('dotenv').config();
const SPREADSHEET_ID = process.env.SPREADSHEET_ID

// TODO: should have a script to export the crentials from env vars to file?
const CREDENTIAL_JSON = process.env.CREDENTIAL_JSON
const GOOGLE_APPLICATION_CREDENTIALS = process.env.GOOGLE_APPLICATION_CREDENTIALS

mkdirp.sync(path.dirname(GOOGLE_APPLICATION_CREDENTIALS))
fs.writeFileSync(GOOGLE_APPLICATION_CREDENTIALS, CREDENTIAL_JSON)


async function readFromSpreadSheet(spreadsheetId, range) {
  // This method looks for the GCLOUD_PROJECT and GOOGLE_APPLICATION_CREDENTIALS
  // environment variables.
  const auth = new google.auth.GoogleAuth({
    // Scopes can be specified either as an array or as a single, space-delimited string.
    scopes: ['https://www.googleapis.com/auth/spreadsheets']
  });

  const req = {
    spreadsheetId,
    range,
    auth,
  };


  const data = await ss.getAsync(req);

  return data.data.values;
}

async function uploadToSpreadSheet(spreadsheetId, range, values) {
  const auth = new google.auth.GoogleAuth({
    // Scopes can be specified either as an array or as a single, space-delimited string.
    scopes: ['https://www.googleapis.com/auth/spreadsheets']
  });

  const data = [{
    range,
    values,
  }];
  // Additional ranges to update ...
  const resource = {
    data,
    valueInputOption: 'USER_ENTERED',
  };
  return ss.batchUpdateAsync({
    spreadsheetId,
    resource,
    auth,
  });
}

async function main() {

  const spreadsheetRecords = await readFromSpreadSheet(SPREADSHEET_ID, 'master!A1:Q')
  spreadsheetRecords.shift();
  spreadsheetRecords.shift();

  console.log(`Spreadsheet read. Total ${spreadsheetRecords.length} records`)

  const recordsEn = await readCSV(process.env.REMOTE_CSV_EN_PATH);
  const recordsZh = await readCSV(process.env.REMOTE_CSV_ZH_PATH);
  // remove header
  recordsEn.shift();
  recordsZh.shift();

  console.log(`CSV fetched. Total ${recordsEn.length} en records and ${recordsZh.length} zh records.`)

  recordsEn.forEach(r => {
    if (!r[0]) {
      return
    }
    const endDate = moment(r[3], 'DD/MM/YYYY', 'YYYY-MM-DD').format('YYYY-MM-DD')
    const index = spreadsheetRecords.findIndex(sr => sr[0] === r[0])

    if (index < 0) {
      spreadsheetRecords.push([
        r[0],
        endDate,
        null,
        r[1],
        null,
        r[2],
        moment().format("YYYY-MM-DD hh:mm:ss")
      ])
    } else if (spreadsheetRecords[index][3] === null) {
      spreadsheetRecords[index][1] = endDate
      spreadsheetRecords[index][3] = r[1]
      spreadsheetRecords[index][5] = r[2]
    }
  })

  recordsZh.forEach(r => {
    if (!r[0]) {
      return
    }
    const endDate = moment(r[3], 'DD/MM/YYYY', 'YYYY-MM-DD').format('YYYY-MM-DD')
    const index = spreadsheetRecords.findIndex(sr => sr[0] === r[0])

    if (index < 0) {
      spreadsheetRecords.push([
        r[0],
        endDate,
        r[1],
        null,
        r[2],
        null,
        moment().format("YYYY-MM-DD hh:mm:ss")
      ])
    } else if (spreadsheetRecords[index][2] === null) {
      spreadsheetRecords[index][1] = endDate
      spreadsheetRecords[index][2] = r[1]
      spreadsheetRecords[index][4] = r[2]
    }
  })

  const values = [['This spreadsheet is generated by bot.', `Last Updated at:${moment().format('YYYY-MM-DD hh:mm:ss')}`], [], ...spreadsheetRecords]
  const result = await uploadToSpreadSheet(SPREADSHEET_ID, 'master!A1:Q', values)
  console.log(`Total ${result.data.totalUpdatedRows} rows updated.`);
}

async function readCSV(csvUrl) {
  const data = await request.getAsync(csvUrl)
  const records = parse(data.body, {
    columns: false,
    skip_empty_lines: true
  })
  return records
}

main().catch(console.error);